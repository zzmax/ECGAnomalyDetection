//
// Created by admin on 16/9/9.
//

/* Deploying MATLAB code to Deploying MATLAB code to lightweight platforms
%% Copyright 2013 - 2013 The MathWorks, Inc. */

/* #include <stdio.h> */

#include "noiseTransform.h" /* autogenerated JNI header */

#include "asSignal.h"
#include "diffKmean.h"
#include "nearKmean.h"
#include "asSignal_initialize.h"
#include "asSignal_emxAPI.h"

//--------------------------------------------------------------------------
/* Function Declarations */
static emxArray_real_T *argInit_Unboundedx1_real_T(void);
static emxArray_real_T *argInit_Unboundedx60_real_T(void);
static double argInit_real_T(void);

/* Function Definitions */
static double argInit_real_T(void)
{
  return 0.0;
}

static emxArray_real_T *argInit_Unboundedx1_real_T(void)
{
  emxArray_real_T *result;
  static int iv1[1] = { 2 };

  int idx0;

  /* Set the size of the array.
     Change this size to the value that the application requires. */
  result = emxCreateND_real_T(1, iv1);

  /* Loop over the array to initialize each element. */
  for (idx0 = 0; idx0 < result->size[0U]; idx0++) {
    /* Set the value of the array element.
       Change this value to the value that the application requires. */
    result->data[idx0] = argInit_real_T();
  }

  return result;
}

static emxArray_real_T *argInit_Unboundedx60_real_T(void)
{
  emxArray_real_T *result;
  static int iv0[2] = { 2, 60 };

  int idx0;
  int idx1;

  /* Set the size of the array.
     Change this size to the value that the application requires. */
  result = emxCreateND_real_T(2, iv0);

  /* Loop over the array to initialize each element. */
  for (idx0 = 0; idx0 < result->size[0U]; idx0++) {
    for (idx1 = 0; idx1 < 60; idx1++) {
      /* Set the value of the array element.
         Change this value to the value that the application requires. */
      result->data[idx0 + result->size[0] * idx1] = argInit_real_T();
    }
  }

  return result;
}

//========================================================================

/*
 * Class:     com_zzmax_admin_ecganomalydetection_noiseTransform
 * Method:    initialize
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_zzmax_admin_ecganomalydetection_noiseTransform_initialize
  (JNIEnv *env, jclass cls)
{
    asSignal_initialize();
}

/*
 * Class:     com_zzmax_admin_ecganomalydetection_noiseTransform
 * Method:    nearKmean
 * Signature: ([[D[[D)[[D
 */
JNIEXPORT jobjectArray JNICALL Java_com_zzmax_admin_ecganomalydetection_noiseTransform_nearKmean
  (JNIEnv *env, jclass cls, jobjectArray a, jobjectArray b)
{
    emxArray_real_T *clusters;
    emxArray_real_T *data;
    emxArray_real_T *clusterIndices;
    emxInitArray_real_T(&clusterIndices, 2);


    // Get a class reference for double
    jclass classDouble = (*env)->FindClass(env, "[D");


    // Get the length (number of double arrays) of the object array passed in
    int numArrays = (*env)->GetArrayLength(env, a);
    /* Initialize function 'asSignal' input arguments. */
    /* Initialize function input argument 'diffWindows'. */
    int iv0[2] = { numArrays, 60 };

    int idx0;
    int idx1;

    /* Set the size of the array.
       Change this size to the value that the application requires. */
    clusters = emxCreateND_real_T(2, iv0);

    numArrays = (*env)->GetArrayLength(env, b);
    iv0[0] = numArrays;
    data = emxCreateND_real_T(2, iv0);

    /* Loop over the array to initialize each element. */
    for (idx0 = 0; idx0 < clusters->size[0U]; idx0++) {
        // get the object at the i'th position (double array)
        jdoubleArray array = (jdoubleArray) (*env)->GetObjectArrayElement(env, a, idx0);

        jsize length = (*env)->GetArrayLength(env, array);

        jdouble *elements = (*env)->GetDoubleArrayElements(env,array,0);

        for (idx1 = 0; idx1 < 60; idx1++) {
            /* Set the value of the array element.
               Change this value to the value that the application requires. */
            clusters->data[idx0 + clusters->size[0] * idx1] = elements[idx1];
        }

        (*env)->ReleaseDoubleArrayElements(env, array, elements, 0); /* deleting the temporary C array */
        (*env)->DeleteLocalRef(env,array);
    }


    for (idx0 = 0; idx0 < data->size[0U]; idx0++) {
        // get the object at the i'th position (double array)
        jdoubleArray array = (jdoubleArray) (*env)->GetObjectArrayElement(env, b, idx0);

        jsize length = (*env)->GetArrayLength(env, array);

        jdouble *elements = (*env)->GetDoubleArrayElements(env,array,0);

        for (idx1 = 0; idx1 < 60; idx1++) {
            /* Set the value of the array element.
               Change this value to the value that the application requires. */
            data->data[idx0 + data->size[0] * idx1] = elements[idx1];
        }

        (*env)->ReleaseDoubleArrayElements(env, array, elements, 0); /* deleting the temporary C array */
        (*env)->DeleteLocalRef(env,array);
    }

    iv0[1] = 1;
    clusterIndices  = emxCreateND_real_T(2, iv0);
    /* Call the entry-point 'asSignal'. */
    clusterIndices = nearKmean(clusters, data, clusterIndices);

    jobjectArray outJNIArray = (*env)->NewObjectArray(env, clusterIndices->size[0U], classDouble, NULL);

    for (idx0 = 0; idx0 < clusterIndices->size[0U]; idx0++) {
        jdoubleArray array = (*env)->NewDoubleArray(env, clusterIndices->size[1U]);

        for (idx1 = 0; idx1 < clusterIndices->size[1U]; idx1++) {
            /* copy elements to a double array */
            jdouble *body = (*env)->GetDoubleArrayElements(env,array, 0);
            body[idx1] = clusterIndices->data[idx0 + clusterIndices->size[0] * idx1];
            (*env)->ReleaseDoubleArrayElements(env, array, body, 0);
        }
        //copy array elements to output JNI array
        (*env)->SetObjectArrayElement(env, outJNIArray, idx0, array);
        /* deleting the temporary C array */
        (*env)->DeleteLocalRef(env,array);
    }

    emxDestroyArray_real_T(clusters);
    emxDestroyArray_real_T(data);
    emxDestroyArray_real_T(clusterIndices);

    return outJNIArray;
}


/*
 * Class:     com_zzmax_admin_ecganomalydetection_noiseTransform
 * Method:    diffKmean
 * Signature: ([[D[[D[[D)[[D
 */
JNIEXPORT jobjectArray JNICALL Java_com_zzmax_admin_ecganomalydetection_noiseTransform_diffKmean
  (JNIEnv *env, jclass cls, jobjectArray a, jobjectArray b, jobjectArray c)
{
    /*jdouble result;

    double* ac = (*env)->GetDoubleArrayElements(env,a,0);
    double* bc = (*env)->GetDoubleArrayElements(env,b,0);

    result = func2(ac, bc);

    (*env)->ReleaseDoubleArrayElements(env, a, ac, 0);
    (*env)->ReleaseDoubleArrayElements(env, b, bc, 0);

    return result;*/
}

/*
 * Class:     com_zzmax_admin_ecganomalydetection_noiseTransform
 * Method:    asSignal
 * Signature: ([[D)[[D
 */
JNIEXPORT jobjectArray JNICALL Java_com_zzmax_admin_ecganomalydetection_noiseTransform_asSignal
  (JNIEnv *env, jclass cls, jobjectArray a)
{

    emxArray_real_T *reconstruct;
    emxArray_real_T *diffWindows;
    emxInitArray_real_T(&reconstruct, 2);


        // Get a class reference for double
       jclass classDouble = (*env)->FindClass(env, "[D");

       // Get the length (number of double arrays) of the object array passed in
       int numArrays = (*env)->GetArrayLength(env, a);
      /* Initialize function 'asSignal' input arguments. */
      /* Initialize function input argument 'diffWindows'. */
      int iv0[2] = { numArrays, 60 };

      int idx0;
      int idx1;

      /* Set the size of the array.
         Change this size to the value that the application requires. */
      diffWindows = emxCreateND_real_T(2, iv0);
    /* Loop over the array to initialize each element. */
      for (idx0 = 0; idx0 < diffWindows->size[0U]; idx0++) {
         // get the object at the i'th position (double array)
          jdoubleArray array = (jdoubleArray) (*env)->GetObjectArrayElement(env, a, idx0);

          unsigned int length = (*env)->GetArrayLength(env, array);

          jdouble *elements = (*env)->GetDoubleArrayElements(env,array,0);

        for (idx1 = 0; idx1 < 60; idx1++) {
          /* Set the value of the array element.
             Change this value to the value that the application requires. */
          diffWindows->data[idx0 + diffWindows->size[0] * idx1] = elements[idx1];
        }

        (*env)->ReleaseDoubleArrayElements(env, array, elements, 0); /* deleting the temporary C array */
          (*env)->DeleteLocalRef(env,array);
      }

     /* Call the entry-point 'asSignal'. */
      reconstruct = asSignal(diffWindows, reconstruct);

    jobjectArray outJNIArray = (*env)->NewObjectArray(env, reconstruct->size[0U], classDouble, NULL);

    for (idx0 = 0; idx0 < reconstruct->size[0U]; idx0++) {
        jdoubleArray array = (*env)->NewDoubleArray(env, reconstruct->size[1U]);

        for (idx1 = 0; idx1 < reconstruct->size[1U]; idx1++) {
            /* copy elements to a double array */
            jdouble *body = (*env)->GetDoubleArrayElements(env,array, 0);
            body[idx1] = reconstruct->data[idx0 + reconstruct->size[0] * idx1];
            (*env)->ReleaseDoubleArrayElements(env, array, body, 0);
        }
        //copy array elements to output JNI array
        (*env)->SetObjectArrayElement(env, outJNIArray, idx0, array);
        /* deleting the temporary C array */
        (*env)->DeleteLocalRef(env,array);
    }

      emxDestroyArray_real_T(reconstruct);
      emxDestroyArray_real_T(diffWindows);
//        (*env)->DeleteLocalRef(env,array);
    return outJNIArray;
}

/*
 * Class:     example
 * Method:    func4
 * Signature: ([F[F)[F
 */
/*JNIEXPORT jdoubleArray JNICALL Java_com_zzmax_admin_example3_example_func4
  (JNIEnv *env, jclass cls, jdoubleArray a, jdoubleArray b)
{
    jdouble temp[9];
    double* ac = (*env)->GetDoubleArrayElements(env,a,0);
    double* bc = (*env)->GetDoubleArrayElements(env,b,0);
    /* creating new JAVA array */
/*    jdoubleArray result = (*env)->NewDoubleArray(env, 9);
    if (result != NULL) {
        //func4(ac, bc, temp);
        /* copying the C array to Java array */
/*        (*env)->SetDoubleArrayRegion(env, result, 0, 9, temp);
    }

    (*env)->ReleaseDoubleArrayElements(env, a, ac, 0);
    (*env)->ReleaseDoubleArrayElements(env, b, bc, 0);

    return result;
}


/*JNIEXPORT jdoubleArray JNICALL Java_com_zzmax_admin_example3_example_kalmanfilter
  (JNIEnv *env, jclass cls, jdoubleArray a)*/
//{
  //  jdouble temp[2];
    /* copying JAVA array to C array */
//    jdouble* ac = (*env)->GetDoubleArrayElements(env,a,0);
    /* creating new JAVA array */
//    jdoubleArray result = (*env)->NewDoubleArray(env, 3);
//    if (result != NULL) {
//        kalmanfilter(ac, temp);
        /* copying the C array to Java array */
//        (*env)->SetDoubleArrayRegion(env, result, 0, 3, temp);
//    }
    /* deleting temporary C array */
//    (*env)->ReleaseDoubleArrayElements(env, a, ac, 0);
//    return result;
//}


